<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Flux VR</title>
  <style>
    .template-wrap { bottom: 0; top: auto; }
    .display-on-load {display: none; }
    .loading-message {
      font-size: 3em;
      padding: : 2em;
      text-align: center;
    }
    .sharable-url {
      padding: 2em;
    }
    li {
      border-radius: .5em;
      padding: 1em;
      font-size: 1em;
    }
    li:hover {
      background-color: #aaa;
    }
    .controls {
      font-size: 2em;
      padding: 20px;
    }
    .controls input {
      width:200px;
    }
  </style>

  <!-- Unity autogenerated files -->
  <link rel="stylesheet" href="TemplateData/style.css">
  <script src="TemplateData/UnityProgress.js"></script>

  <!-- Flux SDK -->
  <script type="text/javascript" src="https://npmcdn.com/flux-sdk-browser@0.3.0/dist/flux-sdk-min.js"></script>

  <!-- Flux Data Selector -->
  <script type="text/javascript" src="flux-data-selector/flux-data-selector.js"></script>
</head>

<div class="display-on-load controls" style="padding:20px;">
  <button class="allow-mouse-controls-button" style="font-size:30px;height:50px;">Use mouse</button>
  <button class="allow-mouse-controls-button" style="font-size:30px;height:50px;"></button>
  <button class="switch-camera-button" style="font-size:30px;height:50px;">
    Switch to desktop mode
  </button>
  <input class="size-input" placeholder="Geometry size"></input>
  <ul class="loaded-keys-list">  </ul>
</div>

<script>
  (function(context) {

    // Prevent the scary "WebGL not supported on mobile!" message in
    // Unity's autogenerated code. Nothing is supposed to depend on
    // window.userAgent or .vendor, but it could mess up analytics.
    // Use this at your own risk.
    navigator.__defineGetter__('userAgent', function(){ return ' '; });
    navigator.__defineGetter__('vendor', function(){ return ' '; });


  /**
   * Key list module
   */

    // Initialize data selector module (not the data selector UI).
    context.ds = new FluxDataSelector("fa4e6dc7-c032-4089-a5b7-4ae367c6d006",
      'https://flux-unity.herokuapp.com/');

    // Creates a hashmap, which will be used to remember all loaded keys.
    var keyList = {};

    var loadedKeysList = document.querySelector('.loaded-keys-list');
    var LoadingMessage = document.createElement('p');
    LoadingMessage.textContent = "Loading, this can take a while...";
    LoadingMessage.classList.add("loading-message");
    document.body.appendChild(LoadingMessage);

    // This callback accepts new data keys as well as update information
    // for data keys that have already been loaded.
    // It is bound to the data selector's onValue callback.
    function LoadDataKey(datakey) {
      if (keyList[datakey.id]) {
        SendMessage("flux", "CreateGeometry",
          datakey.id + JSON.stringify(datakey.value));
      } else {
        keyList[datakey.id] = {
          id: datakey.id,
          label: datakey.label
        };
        SendMessage("flux", "CreateGeometry",
          datakey.id + JSON.stringify(datakey.value));
      }
      makeKeyList();
    };

    function makeKeyList(removeList) {
      var sharableUrl = "/?project=" +
        ds.selectedProjectId;
      while (loadedKeysList.firstChild) {
        loadedKeysList.removeChild(loadedKeysList.firstChild);
      }
      var idx = 0;
      for (key in keyList) {
        var li = document.createElement('li');
        li.textContent = "Key " + ++idx + ": " + keyList[key].label +
          ". Click to delete";
        li.addEventListener('click', (function(id) {
          return function(e) {
            SendMessage("flux", "DeleteGeometry", keyList[id].id);
            loadedKeysList.removeChild(e.target);
            delete keyList[id];
            makeKeyList();
          };
        })(keyList[key].id));
        loadedKeysList.appendChild(li);
        sharableUrl += "&key=" + keyList[key].id;
      }

      if (removeList) {
        history.pushState(null, null, context.location.origin);
      } else {
        // Change the controls to display
        var urlDiv = document.createElement('div');
        urlDiv.classList.add('sharable-url');
        var inputLabel = document.createElement('label');
        var input = document.createElement('input');
        inputLabel.textContent = "Sharable url:";
        input.value = context.location.origin + '/view' + sharableUrl;
        urlDiv.appendChild(inputLabel);
        urlDiv.appendChild(input);
        loadedKeysList.appendChild(urlDiv);
        history.pushState(null, null, sharableUrl);
      }

      completeInitialLoading();
    };

    function ResetKeyList() {
      for (key in keyList) {
        SendMessage("flux", "DeleteGeometry", keyList[key].id);
      }
      keyList = {};
      makeKeyList(true);
    };

    // Show elements that aren't supposed to appear until everything is loaded.
    function completeInitialLoading() {
      // If this function has already run once, it won't run again.
      var alreadyRan = false;
      return (function() {
        if(alreadyRan) return;
        alreadyRan = true;
        context.keyListModule.LoadingMessage.style.display = "none";
        var displayOnLoad = document.querySelectorAll('.display-on-load');
        Array.prototype.forEach.call(displayOnLoad, function(item) {
          item.style.display = "block";
        });
      })();
    };

    context.keyListModule = {
      LoadDataKey: LoadDataKey,
      LoadingMessage: LoadingMessage,
      ResetKeyList: ResetKeyList
    };

  /**
   * Loaded is called when the webgl viewport finishes loading.
   */

    function Loaded(arg) {

      // Search the url for a project and keys.
      var proj = (x = /[?&](project)=([\d\w]*)/.exec(context.location.search)) ?
        x[2] : null;
      if (proj) {
        // This doesn't work yet.
        // $('.projects-selection-dropdown > div.menu')
        //   .append('<div class="item" data-value=' + proj +'>'+proj+'</div>');
        context.ds.selectProject(proj);
      }

      var noMatches = true, regex = /[?&](key)=([\d\w]*)/g, result;
      while((result = regex.exec(context.location.search)) !== null) {
          noMatches = false;
          context.ds.selectKey(result[2])
      }
      if (noMatches) completeInitialLoading();
    }
    context.Loaded = Loaded;

  /**
   * Event handlers for html elements
   */

    // Switches whether Use a stereoscopic camera with head tracking or
    // a monoscopic camera with mouse movement.
    document.querySelector('.switch-camera-button')
    .addEventListener('click', (function() {
      var desktopMode = false;
      function switchCameraHandler() {
        // If this has an accellerometer, initialize head tracking.
        if (context.DeviceMotionEvent !== undefined) {
          context.ondevicemotion = function(event) {
            ax = event.accelerationIncludingGravity.x
            ay = event.accelerationIncludingGravity.y
            az = event.accelerationIncludingGravity.z
            rotation = event.rotationRate;
            if (rotation != null && rotation.alpha != null) {
              SendMessage("player", "MoveMouseX", rotation.alpha/10);
              SendMessage("player", "MoveMouseY", rotation.beta/10);
              // Could do something with gamma eventually...
              // arGamma = Math.round(rotation.gamma);
            }
          }
        }

        SendMessage("player", "SwitchAllowMouseControls");
        SendMessage("player", "SwitchCameraMode");
        desktopMode = !desktopMode;
        document.querySelector('.switch-camera-button').textContent =
          desktopMode ? "Switch to mobile mode" : "Switch to desktop mode";
      };
      return switchCameraHandler;
    })());

    // Sets the size of loaded geometry in the Unity context.
    function sizeInputHandler(e) {
      if (typeof e.target.value !== "number") return;
      SendMessage("flux", "SetSize", parseFloat(e.target.value));

      var input = document.querySelector('.size-input');
      while (input.firstChild) {
        input.removeChild(input.firstChild);
      }
      var sizeChangedMessage = document.createElement('p');
      sizeChangedMessage.textContent = "Changed size to " + e.target.value;
      document.body.appendChild(sizeChangedMessage);
    }
    document.querySelector('.size-input')
    .addEventListener('change', sizeInputHandler);

  })(window);
</script>

